// routes/roomTypes.js - VERS√ÉO COM DISPONIBILIDADE POR PER√çODO
const express = require('express');
const router = express.Router();
const RoomType = require('../models/RoomType');
const { authenticate } = require('../middleware/auth');
const { getDefaultAvailabilityByPeriod, validatePeriodAvailability } = require('../utils/periodAvailability');

// ‚úÖ GET /api/room-types - Listar todos os tipos (COM AUTH)
router.get('/', authenticate, async (req, res) => {
  try {
    console.log('üì• GET /api/room-types - Listando tipos de quarto...');
    
    const roomTypes = await RoomType.findAtivos();
    
    console.log(`‚úÖ ${roomTypes.length} tipos encontrados`);
    
    res.json({
      success: true,
      data: roomTypes,
      message: `${roomTypes.length} tipos de quarto encontrados`
    });
  } catch (error) {
    console.error('‚ùå Erro ao buscar tipos de quarto:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

// ‚úÖ GET /api/room-types/available/:periodo/:contexto - Buscar tipos dispon√≠veis para per√≠odo espec√≠fico
router.get('/available/:periodo/:contexto', authenticate, async (req, res) => {
  try {
    const { periodo, contexto } = req.params;
    console.log(`üì• GET /api/room-types/available/${periodo}/${contexto}`);
    
    if (!['hoje', 'agendado'].includes(contexto)) {
      return res.status(400).json({
        success: false,
        message: 'Contexto deve ser "hoje" ou "agendado"'
      });
    }
    
    const roomTypes = await RoomType.findDisponivelParaPeriodo(periodo, contexto);
    
    res.json({
      success: true,
      data: roomTypes,
      message: `${roomTypes.length} tipos dispon√≠veis para ${periodo} (${contexto})`
    });
  } catch (error) {
    console.error('‚ùå Erro ao buscar tipos dispon√≠veis:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

// ‚úÖ GET /api/room-types/:id - Buscar tipo espec√≠fico (COM AUTH)
router.get('/:id', authenticate, async (req, res) => {
  try {
    console.log(`üì• GET /api/room-types/${req.params.id}`);
    
    const roomType = await RoomType.findOne({ 
      id: req.params.id, 
      'disponibilidade.ativo': true 
    });
    
    if (!roomType) {
      return res.status(404).json({
        success: false,
        message: 'Tipo de quarto n√£o encontrado'
      });
    }
    
    res.json({
      success: true,
      data: roomType,
      message: 'Tipo encontrado'
    });
  } catch (error) {
    console.error('‚ùå Erro ao buscar tipo:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

// ‚úÖ POST /api/room-types - Criar novo tipo (COM AUTH)
router.post('/', authenticate, async (req, res) => {
  try {
    console.log('üì§ POST /api/room-types - Criando novo tipo...');
    console.log('üì¶ Dados recebidos:', req.body);
    
    const { 
      nome, 
      precosPorPeriodo, 
      disponibilidadePorPeriodo,
      amenidades, 
      descricao, 
      configuracao 
    } = req.body;

    if (!nome || !nome.trim()) {
      return res.status(400).json({
        success: false,
        message: 'Nome do tipo √© obrigat√≥rio'
      });
    }

    const id = nome.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');

    // Verificar se j√° existe
    const existingType = await RoomType.findOne({ id });
    if (existingType) {
      return res.status(400).json({
        success: false,
        message: 'Tipo de quarto j√° existe'
      });
    }

    // Buscar a maior ordem atual
    const lastType = await RoomType.findOne().sort({ ordem: -1 });
    const newOrder = lastType ? lastType.ordem + 1 : 1;

    // ‚úÖ PROCESSAR DISPONIBILIDADE POR PER√çODO
    const periodosHoje = [];
    const periodosAgendado = [];
    const disponibilidadeProcessada = new Map();
    
    if (disponibilidadePorPeriodo) {
      Object.entries(disponibilidadePorPeriodo).forEach(([periodoId, config]) => {
        disponibilidadeProcessada.set(periodoId, {
          hoje: config.hoje || false,
          agendado: config.agendado || false,
          availableFor: []
        });
        
        if (config.hoje) {
          periodosHoje.push(periodoId);
          disponibilidadeProcessada.get(periodoId).availableFor.push('today');
        }
        if (config.agendado) {
          periodosAgendado.push(periodoId);
          disponibilidadeProcessada.get(periodoId).availableFor.push('future');
        }
      });
    }

    // ‚úÖ DADOS ATUALIZADOS PARA O NOVO MODELO
    const roomTypeData = {
      id,
      nome: nome.trim(),
      precosPorPeriodo: precosPorPeriodo ? new Map(Object.entries(precosPorPeriodo)) : new Map(),
      disponibilidadePorPeriodo: disponibilidadeProcessada,
      periodosHoje,
      periodosAgendado,
      amenidades: amenidades || ['wifi', 'ar_condicionado', 'tv'],
      descricao: descricao || `Quarto tipo ${nome}`,
      configuracao: configuracao || { capacidadeMaxima: 2 },
      ordem: newOrder,
      criadoPor: req.user?.id || req.user?._id,
      disponibilidade: {
        ativo: true,
        aceitaReservaHoje: periodosHoje.length > 0,
        aceitaReservaAgendada: periodosAgendado.length > 0
      }
    };

    const roomType = new RoomType(roomTypeData);
    await roomType.save();

    console.log('‚úÖ Tipo criado com sucesso:', roomType.id);

    res.status(201).json({
      success: true,
      data: roomType,
      message: `Tipo "${nome}" criado com sucesso`
    });

  } catch (error) {
    console.error('‚ùå Erro ao criar tipo:', error);
    
    if (error.code === 11000) {
      res.status(400).json({
        success: false,
        message: 'Tipo com este ID j√° existe'
      });
    } else if (error.name === 'ValidationError') {
      const errors = Object.values(error.errors).map(err => err.message);
      res.status(400).json({
        success: false,
        message: 'Dados inv√°lidos',
        errors: errors
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Erro ao criar tipo',
        error: error.message
      });
    }
  }
});

// ‚úÖ ROTA PUT CORRIGIDA PARA SALVAR DISPONIBILIDADE
router.put('/:id', authenticate, async (req, res) => {
  try {
    console.log(`üì§ PUT /api/room-types/${req.params.id}`);
    console.log('üì¶ Dados recebidos (COMPLETOS):', JSON.stringify(req.body, null, 2));
    
    const { 
      nome, 
      precosPorPeriodo, 
      disponibilidadePorPeriodo,    // ‚úÖ NOVO: Receber disponibilidade
      configuracoesCompletas,       // ‚úÖ NOVO: Configura√ß√µes completas
      periodosHoje,                 // ‚úÖ NOVO: Lista de per√≠odos para hoje
      periodosAgendado,             // ‚úÖ NOVO: Lista de per√≠odos para agendado
      amenidades, 
      descricao, 
      configuracao, 
      disponibilidade, 
      ativo, 
      active 
    } = req.body;

    // ‚úÖ BUSCAR TIPO EXISTENTE
    const roomType = await RoomType.findOne({ id: req.params.id });
    if (!roomType) {
      console.log(`‚ùå Tipo n√£o encontrado: ${req.params.id}`);
      return res.status(404).json({
        success: false,
        message: 'Tipo de quarto n√£o encontrado'
      });
    }

    console.log('üìã Tipo encontrado:', roomType.nome);

    // ‚úÖ ATUALIZAR NOME
    if (nome && nome.trim()) {
      roomType.nome = nome.trim();
      console.log('‚úÖ Nome atualizado:', roomType.nome);
    }

    // ‚úÖ ATUALIZAR PRE√áOS POR PER√çODO
    if (precosPorPeriodo && typeof precosPorPeriodo === 'object') {
      const precosValidos = Object.entries(precosPorPeriodo).filter(([_, preco]) => 
        typeof preco === 'number' && preco > 0
      );
      
      if (precosValidos.length > 0) {
        roomType.precosPorPeriodo = { ...precosPorPeriodo };
        console.log('‚úÖ Pre√ßos atualizados:', roomType.precosPorPeriodo);
        console.log(`üìä ${precosValidos.length} pre√ßos v√°lidos recebidos`);
      } else {
        console.log('‚ö†Ô∏è Nenhum pre√ßo v√°lido encontrado');
        return res.status(400).json({
          success: false,
          message: '√â necess√°rio pelo menos um pre√ßo v√°lido (maior que zero)'
        });
      }
    }

    // ‚úÖ NOVA SE√á√ÉO: PROCESSAR DISPONIBILIDADE POR PER√çODO
    if (disponibilidadePorPeriodo && typeof disponibilidadePorPeriodo === 'object') {
      console.log('üìÖ Processando disponibilidade por per√≠odo:', disponibilidadePorPeriodo);
      
      // ‚úÖ Criar campos para armazenar no modelo
      if (!roomType.toObject().disponibilidadePorPeriodo) {
        roomType.set('disponibilidadePorPeriodo', {});
      }
      
      // ‚úÖ Salvar disponibilidade completa
      roomType.set('disponibilidadePorPeriodo', disponibilidadePorPeriodo);
      
      // ‚úÖ Extrair listas de per√≠odos por contexto
      const periodosHojeExtraidos = [];
      const periodosAgendadoExtraidos = [];
      
      Object.entries(disponibilidadePorPeriodo).forEach(([periodoId, config]) => {
        console.log(`   üìã ${periodoId}: hoje=${config.hoje}, agendado=${config.agendado}`);
        
        if (config.hoje === true) {
          periodosHojeExtraidos.push(periodoId);
        }
        if (config.agendado === true) {
          periodosAgendadoExtraidos.push(periodoId);
        }
      });
      
      // ‚úÖ Salvar listas extra√≠das
      roomType.set('periodosHoje', periodosHojeExtraidos);
      roomType.set('periodosAgendado', periodosAgendadoExtraidos);
      
      console.log('‚úÖ Per√≠odos HOJE extra√≠dos:', periodosHojeExtraidos);
      console.log('‚úÖ Per√≠odos AGENDADO extra√≠dos:', periodosAgendadoExtraidos);
    }

    // ‚úÖ PROCESSAR CONFIGURA√á√ïES COMPLETAS (SE ENVIADO)
    if (configuracoesCompletas && typeof configuracoesCompletas === 'object') {
      console.log('üîß Salvando configura√ß√µes completas:', configuracoesCompletas);
      roomType.set('configuracoesCompletas', configuracoesCompletas);
    }

    // ‚úÖ PROCESSAR LISTAS DIRETAS (SE ENVIADO)
    if (periodosHoje && Array.isArray(periodosHoje)) {
      console.log('üìã Per√≠odos HOJE recebidos diretamente:', periodosHoje);
      roomType.set('periodosHoje', periodosHoje);
    }

    if (periodosAgendado && Array.isArray(periodosAgendado)) {
      console.log('üìã Per√≠odos AGENDADO recebidos diretamente:', periodosAgendado);
      roomType.set('periodosAgendado', periodosAgendado);
    }

    // ‚úÖ OUTROS CAMPOS (SEM MUDAN√áAS)
    if (amenidades && Array.isArray(amenidades)) {
      roomType.amenidades = amenidades;
      console.log('‚úÖ Amenidades atualizadas');
    }

    if (descricao !== undefined) {
      roomType.descricao = descricao;
      console.log('‚úÖ Descri√ß√£o atualizada');
    }

    if (configuracao && typeof configuracao === 'object') {
      roomType.configuracao = { ...roomType.configuracao, ...configuracao };
      console.log('‚úÖ Configura√ß√£o atualizada');
    }

    if (disponibilidade && typeof disponibilidade === 'object') {
      roomType.disponibilidade = { ...roomType.disponibilidade, ...disponibilidade };
      console.log('‚úÖ Disponibilidade geral atualizada');
    }

    // ‚úÖ CAMPOS DE ATIVA√á√ÉO
    if (ativo !== undefined) {
      roomType.ativo = ativo;
      roomType.active = ativo;
      if (!roomType.disponibilidade) roomType.disponibilidade = {};
      roomType.disponibilidade.ativo = ativo;
      console.log('‚úÖ Status ativo atualizado:', ativo);
    }

    if (active !== undefined) {
      roomType.active = active;
      roomType.ativo = active;
      if (!roomType.disponibilidade) roomType.disponibilidade = {};
      roomType.disponibilidade.ativo = active;
      console.log('‚úÖ Status active atualizado:', active);
    }
    
    // ‚úÖ AUDITORIA
    roomType.atualizadoPor = req.user?.id || req.user?._id;

    // ‚úÖ SALVAR NO BANCO
    console.log('üíæ Salvando no banco de dados...');
    console.log('üîç Dados que ser√£o salvos:');
    console.log('   üìä Pre√ßos:', roomType.precosPorPeriodo);
    console.log('   üìÖ Disponibilidade:', roomType.get('disponibilidadePorPeriodo'));
    console.log('   üöÄ Per√≠odos Hoje:', roomType.get('periodosHoje'));
    console.log('   üìÖ Per√≠odos Agendado:', roomType.get('periodosAgendado'));
    
    await roomType.save();

    console.log('‚úÖ Tipo salvo com sucesso no banco');

    // ‚úÖ VERIFICAR SE DADOS FORAM SALVOS CORRETAMENTE
    const tipoVerificacao = await RoomType.findOne({ id: req.params.id });
    console.log('üîç VERIFICA√á√ÉO P√ìS-SAVE:');
    console.log('   üí∞ Pre√ßos salvos:', tipoVerificacao.precosPorPeriodo);
    console.log('   üìÖ Disponibilidade salva:', tipoVerificacao.get('disponibilidadePorPeriodo'));
    console.log('   üöÄ Per√≠odos Hoje salvos:', tipoVerificacao.get('periodosHoje'));
    console.log('   üìÖ Per√≠odos Agendado salvos:', tipoVerificacao.get('periodosAgendado'));

    // ‚úÖ RESPOSTA DE SUCESSO COM DADOS COMPLETOS
    res.json({
      success: true,
      data: {
        ...tipoVerificacao.toJSON(),
        // ‚úÖ Garantir que dados de disponibilidade s√£o retornados
        disponibilidadePorPeriodo: tipoVerificacao.get('disponibilidadePorPeriodo'),
        configuracoesCompletas: tipoVerificacao.get('configuracoesCompletas'),
        periodosHoje: tipoVerificacao.get('periodosHoje'),
        periodosAgendado: tipoVerificacao.get('periodosAgendado')
      },
      message: `Tipo "${roomType.nome}" atualizado com sucesso`,
      debug: {
        periodosHojeSalvos: tipoVerificacao.get('periodosHoje')?.length || 0,
        periodosAgendadoSalvos: tipoVerificacao.get('periodosAgendado')?.length || 0,
        disponibilidadeSalva: !!tipoVerificacao.get('disponibilidadePorPeriodo')
      }
    });

  } catch (error) {
    console.error('‚ùå Erro ao atualizar tipo:', error);
    
    if (error.name === 'ValidationError') {
      const errors = Object.values(error.errors).map(err => err.message);
      console.error('‚ùå Erros de valida√ß√£o:', errors);
      res.status(400).json({
        success: false,
        message: 'Dados inv√°lidos',
        errors: errors
      });
    } else if (error.name === 'CastError') {
      console.error('‚ùå Erro de tipo de dados:', error.message);
      res.status(400).json({
        success: false,
        message: 'Formato de dados inv√°lido'
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Erro interno do servidor ao atualizar tipo',
        error: error.message
      });
    }
  }
});

// ‚úÖ PUT /api/room-types/:id/periodo/:periodoId - Atualizar disponibilidade de per√≠odo espec√≠fico
router.put('/:id/periodo/:periodoId', authenticate, async (req, res) => {
  try {
    const { id, periodoId } = req.params;
    const { hoje, agendado, preco } = req.body;

    console.log(`üì§ PUT /api/room-types/${id}/periodo/${periodoId}`, { hoje, agendado, preco });

    const roomType = await RoomType.findOne({ id });
    if (!roomType) {
      return res.status(404).json({
        success: false,
        message: 'Tipo de quarto n√£o encontrado'
      });
    }

    // ‚úÖ ATUALIZAR DISPONIBILIDADE DO PER√çODO
    if (hoje !== undefined || agendado !== undefined) {
      roomType.setDisponibilidadePeriodo(
        periodoId, 
        hoje !== undefined ? hoje : roomType.isPeriodoDisponivelHoje(periodoId),
        agendado !== undefined ? agendado : roomType.isPeriodoDisponivelAgendado(periodoId)
      );
    }

    // ‚úÖ ATUALIZAR PRE√áO DO PER√çODO
    if (preco !== undefined && typeof preco === 'number' && preco >= 0) {
      roomType.setPrecoPorPeriodo(periodoId, preco);
    }

    roomType.atualizadoPor = req.user?.id || req.user?._id;
    await roomType.save();

    console.log(`‚úÖ Per√≠odo ${periodoId} atualizado para tipo ${roomType.nome}`);

    res.json({
      success: true,
      message: `Per√≠odo ${periodoId} atualizado com sucesso`,
      data: {
        id: roomType.id,
        nome: roomType.nome,
        periodo: {
          id: periodoId,
          hoje: roomType.isPeriodoDisponivelHoje(periodoId),
          agendado: roomType.isPeriodoDisponivelAgendado(periodoId),
          preco: roomType.getPrecoPorPeriodo(periodoId)
        }
      }
    });

  } catch (error) {
    console.error('‚ùå Erro ao atualizar per√≠odo:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao atualizar per√≠odo',
      error: error.message
    });
  }
});

// ‚úÖ DELETE /api/room-types/:id - Deletar tipo (COM AUTH)
router.delete('/:id', authenticate, async (req, res) => {
  try {
    console.log(`üóëÔ∏è DELETE /api/room-types/${req.params.id}`);
    
    // Verificar se n√£o √© um tipo padr√£o
    const protectedTypes = ['standard', 'premium', 'luxo', 'suite'];
    if (protectedTypes.includes(req.params.id)) {
      return res.status(400).json({
        success: false,
        message: 'N√£o √© poss√≠vel deletar tipos padr√£o'
      });
    }

    const roomType = await RoomType.findOne({ id: req.params.id });
    if (!roomType) {
      return res.status(404).json({
        success: false,
        message: 'Tipo de quarto n√£o encontrado'
      });
    }

    // Verificar se h√° quartos usando este tipo
    const Room = require('../models/Room');
    const roomsWithType = await Room.countDocuments({ 
      type: req.params.id, 
      isActive: true 
    });
    
    if (roomsWithType > 0) {
      return res.status(400).json({
        success: false,
        message: `N√£o √© poss√≠vel deletar. Existem ${roomsWithType} quartos usando este tipo.`,
        data: { roomsCount: roomsWithType }
      });
    }

    // Soft delete
    roomType.disponibilidade.ativo = false;
    roomType.ativo = false;
    roomType.active = false;
    roomType.atualizadoPor = req.user?.id || req.user?._id;
    await roomType.save();

    console.log('‚úÖ Tipo deletado (soft):', roomType.nome);

    res.json({
      success: true,
      message: `Tipo "${roomType.nome}" removido com sucesso`
    });

  } catch (error) {
    console.error('‚ùå Erro ao deletar tipo:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao deletar tipo',
      error: error.message
    });
  }
});

// ‚úÖ POST /api/room-types/init - Inicializar tipos padr√£o (COM AUTH)
router.post('/init', authenticate, async (req, res) => {
  try {
    console.log('üèóÔ∏è POST /api/room-types/init - Inicializando tipos padr√£o...');
    
    // Verificar se usu√°rio √© admin
    if (req.user?.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Apenas administradores podem inicializar tipos padr√£o'
      });
    }

    const tiposCriados = await RoomType.criarTiposPadrao();

    res.json({
      success: true,
      data: tiposCriados,
      message: 'Tipos padr√£o inicializados com sucesso'
    });

  } catch (error) {
    console.error('‚ùå Erro ao inicializar tipos:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao inicializar tipos',
      error: error.message
    });
  }
});

module.exports = router;
