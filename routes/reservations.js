// routes/reservations.js - VERS√ÉO LIMPA (SEM CONFLITOS DE MODELO)

const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');

// ‚úÖ IMPORTAR MODELO DO ARQUIVO SEPARADO (EVITA CONFLITOS)
const Reservation = require('../models/Reservation');

console.log('‚úÖ Modelo Reservation importado com sucesso');

// ‚úÖ MIDDLEWARE ULTRA SIMPLES
const simpleAuth = (req, res, next) => {
  try {
    const authHeader = req.header('Authorization');
    const token = authHeader ? authHeader.replace('Bearer ', '') : null;
    
    if (!token || token === 'undefined' || token === 'null') {
      return res.status(401).json({
        success: false,
        message: 'Token de acesso necess√°rio'
      });
    }

    // ‚úÖ ACEITAR QUALQUER TOKEN V√ÅLIDO
    req.user = { 
      _id: 'user-default', 
      name: 'Usu√°rio Sistema', 
      role: 'admin'
    };
    
    next();
  } catch (error) {
    console.error('‚ùå Erro no middleware:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno de autentica√ß√£o'
    });
  }
};

// ‚úÖ FUN√á√ÉO PARA BUSCAR QUARTO (COM PROTE√á√ÉO)
const buscarQuartoDisponivel = async () => {
  try {
    // Verificar se modelo Room existe
    if (mongoose.models.Room) {
      const Room = mongoose.model('Room');
      const availableRoom = await Room.findOne({ 
        status: { $in: ['available', 'cleaning'] } 
      }).sort({ number: 1 });
      
      if (availableRoom) {
        console.log(`üè® Quarto real encontrado: ${availableRoom.number}`);
        return {
          id: availableRoom._id.toString(),
          number: availableRoom.number || '101',
          type: availableRoom.type || 'standard'
        };
      }
    }
  } catch (error) {
    console.log('‚ö†Ô∏è Quartos n√£o encontrados:', error.message);
  }
  
  // Fallback - quarto padr√£o
  console.log('üè® Usando quarto padr√£o: 101');
  return {
    id: 'room-default',
    number: '101',
    type: 'standard'
  };
};

// ‚úÖ FUN√á√ÉO PARA ATUALIZAR QUARTO (COM PROTE√á√ÉO)
const atualizarStatusQuarto = async (roomId, status) => {
  try {
    if (mongoose.models.Room && roomId !== 'room-default') {
      const Room = mongoose.model('Room');
      const result = await Room.findByIdAndUpdate(roomId, { 
        status,
        updatedAt: new Date()
      });
      
      if (result) {
        console.log(`‚úÖ Quarto ${result.number} ‚Üí ${status}`);
      }
    }
  } catch (error) {
    console.log('‚ö†Ô∏è N√£o foi poss√≠vel atualizar quarto');
  }
};

// ‚úÖ ROTA 1: LISTAR RESERVAS
router.get('/', simpleAuth, async (req, res) => {
  try {
    console.log('üìã [GET] Listando reservas...');
    
    const reservations = await Reservation.find()
      .sort({ createdAt: -1 })
      .limit(100)
      .lean();

    console.log(`üìã Encontradas ${reservations.length} reservas`);

    // ‚úÖ FORMATO SEGURO PARA FRONTEND
    const formattedReservations = reservations.map(reservation => ({
      _id: reservation._id || '',
      reservationNumber: reservation.reservationNumber || 'N/A',
      
      customer: {
        name: reservation.customerName || 'Cliente n√£o informado',
        phone: reservation.customerPhone || '',
        email: reservation.customerEmail || ''
      },
      room: {
        id: reservation.roomId || 'room-default',
        number: reservation.roomNumber || '101'
      },
      checkIn: reservation.checkIn || new Date(),
      checkOut: reservation.checkOut || new Date(),
      periodType: reservation.periodType || '4h',
      pricing: {
        basePrice: reservation.basePrice || 50.00,
        totalPrice: reservation.totalPrice || 50.00
      },
      status: reservation.status || 'confirmed',
      paymentMethod: reservation.paymentMethod || 'cash',
      createdAt: reservation.createdAt || new Date(),
      
      // ‚úÖ COMPATIBILIDADE COM FRONTEND ANTIGO
      cliente: {
        nome: reservation.customerName || 'Cliente n√£o informado',
        telefone: reservation.customerPhone || ''
      },
      data: reservation.checkIn ? new Date(reservation.checkIn).toLocaleDateString('pt-BR') : 'N/A',
      periodo: reservation.periodName || '4 HORAS',
      valor: (reservation.totalPrice || 50.00).toFixed(2)
    }));

    res.json({
      success: true,
      data: formattedReservations,
      total: formattedReservations.length
    });
    
  } catch (error) {
    console.error('‚ùå Erro ao listar reservas:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

// ‚úÖ ROTA 2: CRIAR RESERVA (ULTRA ROBUSTA)
router.post('/', simpleAuth, async (req, res) => {
  try {
    console.log('üÜï [POST] Criando nova reserva...');
    console.log('üì¶ Body:', JSON.stringify(req.body, null, 2));

    // ‚úÖ EXTRAIR DADOS COM PROTE√á√ÉO TOTAL
    const body = req.body || {};
    const {
      checkIn,
      checkOut,
      periodType = '4h',
      roomId,
      _originalData = {}
    } = body;

    // ‚úÖ VALIDA√á√ïES B√ÅSICAS
    if (!checkIn || !checkOut) {
      console.log('‚ùå Datas obrigat√≥rias ausentes');
      return res.status(400).json({
        success: false,
        message: 'Datas de check-in e check-out s√£o obrigat√≥rias'
      });
    }

    // ‚úÖ VALIDAR E CONVERTER DATAS
    let checkInDate, checkOutDate;
    try {
      checkInDate = new Date(checkIn);
      checkOutDate = new Date(checkOut);
      
      if (isNaN(checkInDate.getTime()) || isNaN(checkOutDate.getTime())) {
        throw new Error('Datas inv√°lidas');
      }
    } catch (dateError) {
      console.log('‚ùå Erro nas datas:', dateError.message);
      return res.status(400).json({
        success: false,
        message: 'Formato de data inv√°lido'
      });
    }

    // ‚úÖ BUSCAR QUARTO DISPON√çVEL
    const room = await buscarQuartoDisponivel();
    
    // ‚úÖ PROCESSAR DADOS ORIGINAIS
    const originalData = _originalData || {};
    
    // ‚úÖ MAPEAR PER√çODO PARA NOME
    const periodNameMap = {
      '4h': '4 HORAS',
      '6h': '6 HORAS', 
      '12h': '12 HORAS',
      'daily': 'DI√ÅRIA',
      'pernoite': 'PERNOITE'
    };

    // ‚úÖ MAPEAR PRE√áOS
    const priceMap = {
      '4h': 50.00,
      '6h': 70.00,
      '12h': 100.00,
      'daily': 150.00,
      'pernoite': 120.00
    };

    const basePrice = parseFloat(originalData.valor) || priceMap[periodType] || 50.00;

    // ‚úÖ MAPEAR PAGAMENTO
    const paymentMethodMap = {
      'Dinheiro': 'cash',
      'Cart√£o': 'card', 
      'Pix': 'pix',
      'Transfer√™ncia': 'transfer'
    };

    const paymentMethod = paymentMethodMap[originalData.pagamento] || 'cash';

    // ‚úÖ DADOS SEGUROS PARA SALVAR
    const reservationData = {
      customerName: String(originalData.nome || 'Cliente n√£o informado').trim(),
      customerPhone: String(originalData.telefone || '').trim(),
      customerEmail: String(originalData.email || '').trim(),
      customerDocument: String(originalData.documento || '').trim(),
      
      roomId: room.id,
      roomNumber: room.number,
      
      checkIn: checkInDate,
      checkOut: checkOutDate,
      
      periodType: periodType,
      periodName: periodNameMap[periodType] || '4 HORAS',
      
      basePrice: basePrice,
      totalPrice: basePrice,
      
      status: 'confirmed',
      paymentMethod: paymentMethod,
      paymentStatus: 'paid',
      
      notes: `Cliente: ${originalData.nome || 'N/A'} | Tel: ${originalData.telefone || 'N/A'} | Pagto: ${originalData.pagamento || 'N/A'}`,
      createdBy: req.user._id
    };

    console.log('üíæ Salvando reserva...');

    // ‚úÖ CRIAR E SALVAR RESERVA
    const reservation = new Reservation(reservationData);
    const savedReservation = await reservation.save();

    console.log('‚úÖ Reserva salva:', savedReservation.reservationNumber);

    // ‚úÖ ATUALIZAR STATUS DO QUARTO
    await atualizarStatusQuarto(room.id, 'occupied');

    // ‚úÖ RESPOSTA DE SUCESSO
    res.status(201).json({
      success: true,
      message: 'Reserva criada com sucesso',
      data: {
        reservation: {
          _id: savedReservation._id,
          reservationNumber: savedReservation.reservationNumber,
          customerName: savedReservation.customerName,
          customerPhone: savedReservation.customerPhone,
          roomNumber: savedReservation.roomNumber,
          checkIn: savedReservation.checkIn,
          checkOut: savedReservation.checkOut,
          periodName: savedReservation.periodName,
          totalPrice: savedReservation.totalPrice,
          status: savedReservation.status,
          paymentMethod: savedReservation.paymentMethod,
          createdAt: savedReservation.createdAt
        }
      }
    });

  } catch (error) {
    console.error('‚ùå Erro ao criar reserva:', error);
    
    // ‚úÖ TRATAR ERROS ESPEC√çFICOS
    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: 'N√∫mero de reserva j√° existe'
      });
    }

    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor',
      error: error.message
    });
  }
});

// ‚úÖ ROTA 3: BUSCAR POR ID
router.get('/:id', simpleAuth, async (req, res) => {
  try {
    const { id } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({
        success: false,
        message: 'ID inv√°lido'
      });
    }

    const reservation = await Reservation.findById(id).lean();

    if (!reservation) {
      return res.status(404).json({
        success: false,
        message: 'Reserva n√£o encontrada'
      });
    }

    res.json({
      success: true,
      data: { reservation }
    });
  } catch (error) {
    console.error('‚ùå Erro ao buscar reserva:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// ‚úÖ ROTA 4: ATUALIZAR STATUS
router.patch('/:id/status', simpleAuth, async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    const allowedStatuses = ['pending', 'confirmed', 'checked-in', 'checked-out', 'cancelled'];
    if (!allowedStatuses.includes(status)) {
      return res.status(400).json({
        success: false,
        message: 'Status inv√°lido'
      });
    }
    
    const reservation = await Reservation.findByIdAndUpdate(
      id,
      { status, updatedAt: new Date() },
      { new: true }
    );

    if (!reservation) {
      return res.status(404).json({
        success: false,
        message: 'Reserva n√£o encontrada'
      });
    }

    // ‚úÖ ATUALIZAR QUARTO
    let roomStatus = 'available';
    if (status === 'checked-in') roomStatus = 'occupied';
    else if (status === 'checked-out') roomStatus = 'cleaning';
    
    await atualizarStatusQuarto(reservation.roomId, roomStatus);

    res.json({
      success: true,
      message: `Status atualizado para ${status}`,
      data: { reservation }
    });
  } catch (error) {
    console.error('‚ùå Erro ao atualizar status:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// ‚úÖ ROTA 5: DELETAR
router.delete('/:id', simpleAuth, async (req, res) => {
  try {
    const { id } = req.params;
    
    const reservation = await Reservation.findByIdAndDelete(id);

    if (!reservation) {
      return res.status(404).json({
        success: false,
        message: 'Reserva n√£o encontrada'
      });
    }

    // ‚úÖ LIBERAR QUARTO
    await atualizarStatusQuarto(reservation.roomId, 'available');

    res.json({
      success: true,
      message: 'Reserva deletada com sucesso'
    });
  } catch (error) {
    console.error('‚ùå Erro ao deletar reserva:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// ‚úÖ ROTA 6: ESTAT√çSTICAS
router.get('/stats/overview', simpleAuth, async (req, res) => {
  try {
    const total = await Reservation.countDocuments();
    const active = await Reservation.countDocuments({ status: 'checked-in' });
    const today = new Date();
    const startOfDay = new Date(today.setHours(0, 0, 0, 0));
    const endOfDay = new Date(today.setHours(23, 59, 59, 999));
    
    const todayCount = await Reservation.countDocuments({
      createdAt: { $gte: startOfDay, $lte: endOfDay }
    });

    res.json({
      success: true,
      data: {
        overview: {
          total,
          today: todayCount,
          active,
          totalReservations: total,
          todayReservations: todayCount,
          activeReservations: active
        }
      }
    });
  } catch (error) {
    console.error('‚ùå Erro ao buscar estat√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// ‚úÖ HEALTH CHECK
router.get('/health', (req, res) => {
  res.json({
    success: true,
    message: 'Rotas de reservas funcionando',
    timestamp: new Date().toISOString()
  });
});

console.log('‚úÖ Rotas de reservas registradas com sucesso');

module.exports = router;
